
#original polygen

#PolyGen is broken into two functions
#The first function (polyGen) combines the locus table and read counts into a single file and submits to the second function
#The second funtion (genoSetup) genotypes the data and returns the final genotypes to polyGen where it undergoes final formatting
polyGen<-function(locusTable,readCounts){
  #combine locus information and read counts into single table
  combinedData<-cbind(locusTable,readCounts)
  #pbapply has integrated progress bar, use apply if pbapply cannot be installed
  results<-pbapply(combinedData,1,genoSetup,epsilon=0.01)
  #results<-apply(combinedData,1,genoSetup,epsilon=0.01)
  results<-t(results)
  return(results)
}

testReads<-singleSNP_alleleReads[rownames(singleSNP_alleleReads)=="RAD3524_86",]
testLocusTable<-singleSNP_locusTable[singleSNP_locusTable$Locus_ID=="RAD3524_86",]

genoData<-cbind(testLocusTable,testReads)

genoSetup<-function(genoData,epsilon=0.01){
  readList<-genoData[4:length(genoData)]
  n_alleles<-strsplit(as.character(genoData[3]),",")
  n_alleles<-length(n_alleles[[1]])
  #use numbers in place of actual alleles to allow haplotypes and other allele coding (indel, etc)
  #convert back to actual alleles later
  alleles=as.character(seq(1:n_alleles))
  ploidy=as.numeric(genoData[2])
  #set up possible genotypes
  alleleList<-substr(alleles,1,n_alleles)
  alleleList<-replicate(ploidy, alleleList) 
  #convert to vector, then sort numerically and convert back to text
  alleleList<-as.vector(alleleList)    
  alleleList<-sort(as.numeric(alleleList))
  alleleList<-as.character(alleleList)
  genoCombos<-combn(alleleList,ploidy)
  GenotypeList<-t(genoCombos)
  possibleGenotypes<-unique(GenotypeList)
  
  #make conversion table for genotypes
  realAlleles<-genoData[3]
  realAllelesOrder<-unlist(strsplit(as.character(realAlleles),",",perl=TRUE))
  
  #make table to convert numeric genotype codes to real genotypes
  numericGeno<-apply(possibleGenotypes,1,function(x) paste(x,collapse=""))
  realGenotypes<-apply(possibleGenotypes,2,function(x) realAllelesOrder[as.numeric(x)])
  realGeno<-apply(realGenotypes,1,function(x) paste(x,collapse=","))
  genoConvert<-as.data.frame(t(rbind(numericGeno,realGeno)))
  
  
  #make matrix of relative dosage for each possible genotype
  relative_dosage<-matrix(NA,nrow=dim(possibleGenotypes)[1],ncol=n_alleles)
  
  for(i in 1:n_alleles){
    proportion<-sapply(numericGeno,function(x) str_count(x, alleles[i]))
    proportion<-proportion/ploidy
    relative_dosage[,i]<-proportion
  }
  
  #make matrix of read chances
  read_chances<-matrix(NA,nrow=1,ncol=ploidy)
  #read_chances<-(relative_dosage*(1-epsilon) + (1-relative_dosage)*epsilon)
  #updated error model dividing epsilon by 3 (n alleles -1) where n alleles is the number of possible bases (4, ATCG)
  read_chances<-(relative_dosage*(1-epsilon) + (1-relative_dosage)*epsilon/3)
  
  #make likelihood function
  likelihoodFunc<-function(reads){
    #convert reads to alleles
    #parse allele counts
    if(reads=="."){
      reads<-paste(as.character(replicate(n_alleles, 0)),collapse=",")
    }
    alleleCounts<-as.numeric(unlist(strsplit(reads,",")))
    initLikelihood<-log(1)
    likelihoodMatrix<-matrix(0,nrow=dim(possibleGenotypes)[1],ncol=ploidy)
    #likelihood calculation
    likelihoodMatrix<-t(initLikelihood+log(t(read_chances))*(alleleCounts))
    likelihood<-apply(likelihoodMatrix,1,sum)
    genotypes<-apply(possibleGenotypes,1,function(x) paste(x,collapse=""))
    
    #create likelihood results matrix
    like_of_geno<-as.data.frame(matrix(NA,nrow=dim(possibleGenotypes)[1],ncol=2))
    colnames(like_of_geno)<-c("genotype","likelihood")
    like_of_geno$genotype<-genotypes
    like_of_geno$likelihood<-likelihood
    
    #use a likelihood ratio test to determine the support for the 'best' genotype
    #order likelihoods
    geno_likes<-like_of_geno[order(-like_of_geno$likelihood),]
    #rename rows so they can be extracted in correct order
    rownames(geno_likes)<-1:nrow(geno_likes)
    #compare likelihood ratio of two most likely models
    LR<-2*(geno_likes[1,2]-geno_likes[2,2])
    #get p-value of likelihood ratio
    p<-1-pchisq(LR, 1)
    if(p<0.05){
      genoResult<-geno_likes[1,1]
      genoResult<-genoConvert$realGeno[genoConvert$numericGeno==genoResult]
    }else{
      genoResult<-"0"
    }
    result<-as.character(genoResult)
    return(result)
  }
  
  likelihoods<-sapply(readList,likelihoodFunc)
  return(likelihoods)
}


################################################################################################
#
#                                         FILE CONVERSION
#
################################################################################################
exportGenepop<-function(polygenResults,locusTable,exportParalogs=FALSE,filename="polygenResults.genepop"){
  #use ploidy and allele information from locusTable for genotype conversion and paralog filtering
  #combine locusTable and polyGenResults
  combinedData<-cbind(locusTable,polygenResults)
  #function to convert alleles to numeric code
  alleleConvert<-function(combinedData){
    alleles<-unlist(strsplit(as.character(combinedData[3]),","))
    genotypes<-combinedData[4:length(combinedData)]
    if(nchar(alleles[1])==1){
      numericAlleles<-str_replace_all(genotypes,"0",paste(rep("0",as.numeric(combinedData[2])*2),collapse=""))
      numericAlleles<-str_replace_all(numericAlleles,c("A"="01","C"="02","G"="03","T"="04","-"="05"))
      numericAlleles<-str_replace_all(numericAlleles,",","")
    }else{
      hapAlleles<-unlist(strsplit(as.character(combinedData[3]),","))
      hapAlleleNumbers<-seq(1,length(hapAlleles),by=1)
      #check if number allele for haplotype is already same length as ploidy, if not pad with a 0
      hapAlleleNumbers<-ifelse(hapAlleleNumbers<10,paste("0",hapAlleleNumbers,sep=""),hapAlleleNumbers)
      hapAlleleCode<-hapAlleleNumbers
      names(hapAlleleCode)<-hapAlleles
      numericAlleles<-str_replace_all(genotypes,"0",paste(rep("0",as.numeric(combinedData[2])*2),collapse=""))
      numericAlleles<-str_replace_all(numericAlleles,hapAlleleCode)
      numericAlleles<-str_replace_all(numericAlleles,",","")
    }
    return(numericAlleles)
  }
  #convert bases to genepop code
  genepopBases<-apply(combinedData,1,alleleConvert)
  rownames(genepopBases)<-colnames(polygenResults)
  rownames(genepopBases)<-paste(rownames(genepopBases),",",sep="")
  #exclude paralogs if exportParalogs flag is FALSE
  if(exportParalogs==FALSE){
    genepopBases<-genepopBases[,colnames(genepopBases) %in% locusTable$Locus_ID[locusTable$ploidy==2]]
  }
  #write output file
  write("Title Line:",filename)
  write(colnames(genepopBases),filename,ncolumns=1,append=TRUE)
  write("Pop",filename,append=TRUE)
  write.table(genepopBases,filename,quote=FALSE,sep="\t",col.names=FALSE,append=TRUE)
}

exportRubias<-function(polygenResults,locusTable,sampleMetaData=NULL,filename="polygenResults_rubias.txt"){
  #use ploidy and allele information from locusTable for genotype conversion and paralog filtering
  #combine locusTable and polyGenResults
  combinedData<-cbind(locusTable,polygenResults)
  #replace missing genotypes with NA
  combinedData[combinedData==0]<-NA
  #exclude loci that are paralogs, these are not currently accepted by rubias
  combinedData<-combinedData[combinedData$ploidy==2,]
  #remove Locus_ID, ploidy, and alleles columns and transpose
  genotypes<-t(combinedData[,4:dim(combinedData)[2]])
  #split genotypes into alleles
  splitGenotypes<-as.data.frame(apply(genotypes,2,function(x) data.frame(str_split_fixed(x,",",2))),check.names=FALSE)
  #format column names
  colnames(splitGenotypes)<-str_replace_all(colnames(splitGenotypes),c(".X1",".X2"),c("",".1"))
  #str_replace_all replaces NA with "", fill in missing NAs
  splitGenotypes[splitGenotypes==""]<-NA
  rownames(splitGenotypes)<-rownames(genotypes)
  
  #make new columns for sample type, reporting group, collection, and indivdual
  if(is.null(sampleMetaData)){
    rubiasFile<-data.frame(matrix(NA, nrow=dim(splitGenotypes)[1],ncol=4))
    colnames(rubiasFile)<-c("sample_type","repunit","collection","indiv")
    rubiasFile$indiv<-rownames(genotypes)
    rubiasFile<-cbind(rubiasFile,splitGenotypes)
  }else{
    splitGenotypes$indiv<-rownames(genotypes)
    #combine sample data with genotypes, retain all genotyped samples but include sample data only from genotyped samples
    rubiasFile<-merge(sampleMetaData,splitGenotypes,all.x=FALSE,all.y=TRUE)
    #reorder columns to fit rubias format
    rubiasFile<-rubiasFile[c(2:4,1,5:dim(rubiasFile)[2])]
  }
  write.table(rubiasFile,filename,quote=FALSE,sep="\t",row.names=FALSE,col.names=TRUE)
}
